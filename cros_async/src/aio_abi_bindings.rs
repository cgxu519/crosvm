/* automatically generated by rust-bindgen */
/* bindgen --with-derive-default include/uapi/linux/aio_abi.h
 * __kernel_rwf_t had to be replaced with int
 * Then delete everything that isn't needed.
 * TODO(dgreid) - this is x86_64 only, need to do other arches */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use std::ptr::null;

use libc::{c_long, c_void, syscall, timespec};
use syscall_defines::linux::LinuxSyscall::{SYS_io_getevents, SYS_io_setup, SYS_io_submit};

pub type aio_context_t = ::std::os::raw::c_ulong;
pub const IOCB_CMD_PREAD: u32 = 0;
pub const IOCB_CMD_PWRITE: u32 = 1;
pub const IOCB_CMD_FSYNC: u32 = 2;
pub const IOCB_CMD_FDSYNC: u32 = 3;
pub const IOCB_CMD_POLL: u32 = 5;
pub const IOCB_CMD_NOOP: u32 = 6;
pub const IOCB_CMD_PREADV: u32 = 7;
pub const IOCB_CMD_PWRITEV: u32 = 8;

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_event {
    pub data: u64,
    pub obj: u64,
    pub res: i64,
    pub res2: i64,
}

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iocb {
    pub aio_data: u64,
    pub aio_key: u32,
    pub aio_rw_flags: ::std::os::raw::c_int,
    pub aio_lio_opcode: u16,
    pub aio_reqprio: i16,
    pub aio_fildes: u32,
    pub aio_buf: u64,
    pub aio_nbytes: u64,
    pub aio_offset: i64,
    pub aio_reserved2: u64,
    pub aio_flags: u32,
    pub aio_resfd: u32,
}

// Wrapper around the io_setup syscall.
pub fn io_setup(max_events: usize) -> Result<aio_context_t, c_long> {
    let context: aio_context_t = Default::default();
    unsafe {
        // Safe because the kernel is trusted to only touch the memory owned by `context`.
        let ret = libc::syscall(
            SYS_io_setup as c_long,
            max_events,
            &context as *const _ as *mut c_void,
        );
        if ret < 0 {
            return Err(ret);
        }
    }
    Ok(context)
}

// Wrapper around io_submit syscall.
// To use io_submit safely, the callbacks passed in mut be configured to write to only areas of
// memory that they own exclusively or is contained within a volatile slice.
pub unsafe fn io_submit(cbs: &[iocb]) -> Result<(), c_long> {
    // TODO MaybeUninit
    let mut cb_ptrs = [null(); 128];
    for (ptr, cb) in cb_ptrs.iter_mut().zip(cbs.iter()) {
        *ptr = cb as *const _ as *const c_void;
    }
    let ret = libc::syscall(
        SYS_io_submit as c_long,
        cbs.len() as c_long,
        &cb_ptrs as *const _ as *const *const iocb,
    );
    if ret < 0 {
        return Err(ret);
    }
    Ok(())
}

// Wrapper around io_getevents.
// Only support polling, blocking is not supported.
pub fn io_getevents(context: aio_context_t, events: &mut [io_event]) -> Result<usize, c_long> {
    unsafe {
        // Safe becuase the kernel is trusted to only write within io_events.
        let ret = syscall(
            SYS_io_getevents as c_long,
            context,
            0,
            events.len(),
            events.as_mut_ptr() as *mut io_event,
            null::<timespec>(),
        );
        if ret < 0 {
            return Err(ret);
        }
        Ok(ret as usize)
    }
}
